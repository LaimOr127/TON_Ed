int seqno = 0;  ;; Инициализация seqno

() recv_external(slice in_msg_body) impure {
    ;; Проверка seqno для защиты от повторных сообщений
    int incoming_seqno = in_msg_body~load_uint(32);
    if (incoming_seqno != seqno) {
        throw(100);  ;; Отклоняем сообщение, если seqno не совпадает
    }

    ;; Входящее внешнее сообщение
    var op = in_msg_body~load_uint(32);
    if (op == 3) { ;; Операция 3: отправить ответ контракту A
        ;; Чтение данных
        var to = in_msg_body~load_msg_addr();
        var amount = in_msg_body~load_coins();
        var body = in_msg_body~load_ref();

        ;; Увеличиваем seqno после успешной обработки сообщения
        seqno += 1;

        ;; Отправка bounceable сообщения контракту A
        send_message_with_body(amount, to, body, true); ;; true указывает на bounceable сообщение
    } else {
        ;; Неизвестная операция
        throw(102);
    }
}

() recv_internal(int msg_value, cell msg_body) impure {
    ;; Входящее внутреннее сообщение от Контракта A
    var cs = msg_body.begin_parse();
    var op = cs~load_uint(32);
    if (op == 4) {
        ;; Получение данных от Контракта A
        var sender = cs~load_msg_addr();
        var received_data = cs~load_coins();

        ;; Принятие сообщения и оплата газа
        accept_message();

        ;; Логика обработки данных
        ;; Дополнительные действия можно выполнить здесь
    }
}

() send_message_with_body(int amount, slice to, cell body, bool bounceable) impure inline_ref {
    ;; Сообщение с телом
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(bounceable ? BOUNCEABLE : NON_BOUNCEABLE)  ;; Выбор между bounceable и non-bounceable
        .store_slice(to)        ;; Адрес получателя
        .store_coins(amount)    ;; Сумма перевода
        .store_ref(body)        ;; Тело сообщения
    .end_cell();
    send_raw_message(msg, 64);  ;; Режим 64: сообщение не уничтожает контракт
}
