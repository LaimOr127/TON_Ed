int seqno = 0;  ;; Инициализация seqno

() recv_external(slice in_msg_body) impure {
    ;; Проверка seqno для защиты от повторных сообщений
    int incoming_seqno = in_msg_body~load_uint(32);
    if (incoming_seqno != seqno) {
        throw(100);  ;; Отклоняем сообщение, если seqno не совпадает
    }

    ;; Входящее внешнее сообщение
    var op = in_msg_body~load_uint(32);
    if (op == 1) { ;; Операция 1: отправить сообщение контракту B
        ;; Чтение данных
        var to = in_msg_body~load_msg_addr();
        var amount = in_msg_body~load_coins();
        var body = in_msg_body~load_ref();

        ;; Увеличиваем seqno после успешной обработки сообщения
        seqno += 1;

        ;; Отправка bounceable сообщения контракту B
        send_simple_message(amount, to, body, true); ;; true указывает на bounceable сообщение
    } else {
        ;; Неизвестная операция
        throw(101);
    }
}

() recv_internal(int msg_value, cell msg_body) impure {
    ;; Входящее внутреннее сообщение
    var cs = msg_body.begin_parse();
    var op = cs~load_uint(32);
    if (op == 2) {
        ;; Получение сообщения от Контракта B
        var sender = cs~load_msg_addr();
        var response_data = cs~load_coins();
        
        ;; Принятие сообщения и оплата газа
        accept_message();

        ;; Логика обработки данных от Контракта B
        ;; Дополнительные действия можно выполнить здесь
    }
}

() send_simple_message(int amount, slice to, cell body, bool bounceable) impure inline_ref {
    ;; Простое сообщение с переводом и телом
    cell msg = begin_cell()
        .store_msg_flags_and_address_none(bounceable ? BOUNCEABLE : NON_BOUNCEABLE)  ;; Выбор между bounceable и non-bounceable
        .store_slice(to)        ;; Адрес получателя
        .store_coins(amount)    ;; Сумма перевода
        .store_ref(body)        ;; Тело сообщения
    .end_cell();
    send_raw_message(msg, 1);  ;; Режим 1: сообщение может быть bounced
}
