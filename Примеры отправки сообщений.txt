### ==1. Примеры отправки сообщений в FunC==


#### Пример 1: Простое сообщение с переводом монет



`() send_simple_message(slice to, int amount, int mode) impure inline_ref {
    ;; Формируем сообщение с переводом токенов и пустым телом
    cell msg = begin_cell()
        .store_uint(0x18, 6)    // Тег для внутреннего сообщения
        .store_slice(to)        // Адрес получателя
        .store_coins(amount)    // Сумма перевода
    .end_cell();
    send_raw_message(msg, mode); // Отправляем сообщение
}
`


---

#### Пример 2: Сообщение с телом (текстом)



`() send_message_with_body(slice to, int amount, cell body, int mode) impure inline_ref {
    ;; Формируем сообщение с телом
    cell msg = begin_cell()
        .store_uint(0x18, 6)    // Тег для внутреннего сообщения
        .store_slice(to)        // Адрес получателя
        .store_coins(amount)    // Сумма перевода
        .store_ref(body)        // Тело сообщения
    .end_cell();
    send_raw_message(msg, mode);
}
`

**Пояснение:**  
Этот пример отправляет сообщение с переводом монет и добавляет в сообщение тело (`body`), которое может содержать полезную информацию, например, данные контракта или команды.

---

#### Пример 3: Сообщение с указанием обработки ошибки



`() send_message_with_error_handling(slice to, int amount, cell body, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to)
        .store_coins(amount)
        .store_ref(body)
    .end_cell();

    ;; Указание режима, в котором контракт не уничтожается при ошибке
    send_raw_message(msg, mode | 64); // Флаг 64 для игнорирования ошибок
}
`

**Пояснение:**  
Этот пример добавляет обработку ошибок — сообщение будет отправлено даже если произошла ошибка, и контракт не будет уничтожен. Флаг `64` добавляется к `mode`.

---

#### Пример 4: Сообщение с уничтожением контракта после отправки



`() send_message_and_selfdestruct(slice to, int amount, cell body) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to)
        .store_coins(amount)
        .store_ref(body)
    .end_cell();
    
    ;; Режим 128 означает, что контракт уничтожится после отправки
    send_raw_message(msg, 128);
}
`

**Пояснение:**  
Этот пример отправляет сообщение и уничтожает контракт после успешной отправки. Используется режим `128` для автоматического уничтожения контракта.

---

#### Пример 5: Сообщение с пустым телом и нулевым переводом монет



`() send_empty_message(slice to, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)    // Внутреннее сообщение
        .store_slice(to)        // Адрес получателя
        .store_coins(0)         // Нулевой перевод
    .end_cell();
    
    send_raw_message(msg, mode);
}
`

**Пояснение:**  
Это сообщение отправляется без перевода монет, просто информируя другой контракт о каком-либо событии. Такой тип сообщений часто используется для взаимодействия между контрактами.

---

#### Пример 6: Сообщение с задержкой (использование DePool)


`() send_delayed_message(slice to, int amount, cell body, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)    // Тег для внутреннего сообщения
        .store_slice(to)
        .store_coins(amount)
        .store_ref(body)
    .end_cell();
    
    ;; Задержка отправки сообщения
    send_raw_message_with_delay(msg, 10, mode); // Задержка в 10 блоков
}
`

**Пояснение:**  
Это сообщение будет отправлено с задержкой в 10 блоков, что может быть полезно, если нужно отложить выполнение операции.

---

#### Пример 7: Сообщение с реферальным адресом



`() send_message_with_referral(slice to, slice referral, int amount, cell body, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to)
        .store_coins(amount)
        .store_slice(referral)   // Добавляем реферальный адрес
        .store_ref(body)
    .end_cell();
    
    send_raw_message(msg, mode);
}
`

**Пояснение:**  
Здесь к сообщению добавляется реферальный адрес. Это может использоваться в системах, где реферальная программа встроена в смарт-контракты.

---

#### Пример 8: Сообщение с кастомным кодом операции



`() send_custom_op_message(slice to, int amount, int op_code, cell body, int mode) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(op_code, 32) // Кастомный код операции
        .store_slice(to)
        .store_coins(amount)
        .store_ref(body)
    .end_cell();
    
    send_raw_message(msg, mode);
}
`

---

#### Пример 9: Отправка сообщения с возвратом средств при ошибке



`() send_message_with_fallback(slice to, int amount, cell body) impure inline_ref {
    cell msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(to)
        .store_coins(amount)
        .store_ref(body)
    .end_cell();
    
    ;; Если отправка не удастся, монеты будут возвращены
    send_raw_message(msg, 64);
}
`

**Пояснение:**  
Сообщение отправляется с флагом `64`, который гарантирует возврат средств, если произошла ошибка во время отправки.

---

#### Пример 10: Массовая отправка сообщений



`() send_bulk_messages(slice[] recipients, int amount, cell body, int mode) impure inline_ref {
    for (slice to : recipients) {
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to)
            .store_coins(amount)
            .store_ref(body)
        .end_cell();
        
        send_raw_message(msg, mode);
    }
}
`
